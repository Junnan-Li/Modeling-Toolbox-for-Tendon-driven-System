% Test scripts of finger dynanmic simulation using the (compiled) functions of
% Finger.fordyn_ne_mdh with a given desired joint pose and PD controller
% parameters. 
% The State varables are compared to the results of the simscape model
% generated by the rst model with the same dynamic and control parameters.   
% 
% 
% 02,2023 Junnan Li


clear all
close all
clc


% define different types of fingers

finger_r = Finger('Index', 'RRRR', [1,0.8,0.5]); 

%% set random states
% set base position and orientation
finger_r.w_p_base = 4*zeros(3,1);
finger_r.w_R_base = euler2R_XYZ(zeros(1,3));

% init joint configurations
q_0 = zeros(4,1);

% udpate finger with given joint configurations
finger_r.update_finger(q_0);
% load rst model from finger class
rst_model = finger_r.rst_model;

%% generate simscape model
% finger_SM = smimport(rst_model,ModelName = "testSMfinger2");
% sm_mdl = get_param(finger_SM,"Name");
% helperInstrumentSMModels.instrumentRBTSupportedJointInputs(sm_mdl,finger_SM,"torque")

%% simulation settings
n_q = 4;
q_desired = [0,0,0,pi/2]';
qd_desired = zeros(4,1);
qdd_desired = zeros(4,1);

delta_t = 0.001; % unit s
end_time = 1*60; % unit s
tSpan = 0:delta_t:end_time;
step = length(tSpan); 
initialState = [q_0;zeros(4,1)]; % [q;qd]
F_ext = zeros(6,1);
% controller parameters
P = [2;70;40;5];
D = [2;1;1;5];

% if use mex function
mex = 1;
gravity_com = 0; % if using gravity compensation
%% simulation

state = zeros(2*n_q,step);
state(:,1) = initialState;
state_d = zeros(2*n_q,step);

Tau = zeros(n_q,step);


T = zeros(step,1);
for i = 1:step
    tic;
    
    state_i = state(:,i);
    q_i = state_i(1:n_q);
    qd_i = state_i(n_q+1:end);
%     t_i = i*delta_t;
    %     state_i = [q_i;qd_i];

    q_theta_i = q_desired - q_i;
    qd_theta_i = qd_desired - qd_i;
    
    if gravity_com
        [~,~,~,G_fd] = finger_r.fordyn_ne_w_end(q_i, qd_i, zeros(n_q,1), F_ext);
        Tau_i = P.*q_theta_i + D.*qd_theta_i + G_fd;
    else
        Tau_i = P.*q_theta_i + D.*qd_theta_i;
    end
        
    
    [qdd_i,M_fd,C_fd,G_fd] = finger_r.fordyn_ne_w_end(q_i, qd_i, Tau_i, F_ext, mex);
    
    %     stated_i = rungekutta4(@(t_i,state_i)finger_r.fordyn(t_i ,state_i, Tau_i, F_ext),delta_t,t_i,state_i);
    %     state(:,i+1) = delta_t.*stated_i + state_i;
    %     state_d(:,i) = stated_i;
    
    state_d(1:n_q,i) = qd_i;
    state_d(n_q+1:end,i) = qdd_i;

    state(:,i+1) =  state(:,i)+delta_t.*state_d(:,i);
    Tau(:,i) = Tau_i;
    T(i) = toc;
end

fprintf('average computation cost each step: %f \n', mean(T));
%% Simulink Simscape model

SInput.time = 0 + delta_t*(0:step-1)';
SInput.signals(1).values = repmat(q_desired',step,1);
SInput.signals(1).dimensions = 4;
SInput.signals(2).values = repmat(qd_desired',step,1);
SInput.signals(2).dimensions = 4;

paramStruct.Solver = 'ode1';
paramStruct.StopTime = string(end_time);

out = sim('testSMfinger',paramStruct);

%%
figure(2)
subplot(2,1,1)
plot(tSpan,state(1:n_q,1:end-1)) % Joint position
hold on
plot(tSpan,q_desired.*ones(n_q,length(tSpan)),'--') % Joint setpoint
title(' Joint Position')
xlabel('Time (s)')
ylabel('Position (rad)')
subplot(2,1,2)
plot(tSpan,Tau) % Joint velocity
title('Joint torque')
xlabel('Time (s)')
ylabel('Torque (Nm)')

% compare simscape and scripts
figure(3)

for i = 1:4
    subplot(4,1,i)
    plot(tSpan,state(i,1:end-1)) % Joint position
    hold on
    plot(out.tout,out.q_out.signals.values(:,i), '--') % Joint position
    hold on
    plot(tSpan,q_desired(i).*ones(1,length(tSpan)), 'Color','c') % Joint setpoint
end
title('Compare: Joint Position')
figure(4)
for i = 1:4
    subplot(4,1,i)
    plot(tSpan,state(i,1:end-1)'-out.q_out.signals.values(:,i)) % Joint position
end
title('error: Joint torque input')

figure(5)
for i = 1:4
    subplot(4,1,i)
    plot(tSpan,Tau(i,:)) % Joint position
    hold on
    plot(out.tout,out.tau.signals.values(:,i), '--') % Joint position
end
title('Compare: Joint torque input')


